<!DOCTYPE html>
<html lang="en">

<head>
    <title>Music Program</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        canvas.scope {
            width: 100%;
        }

        .window {
            max-width: 100%;
            border-radius: 8px;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.25);
            overflow: hidden;
            font-family: sans-serif;
            background: #f0f0f0;
            border: 1px solid #ccc;
        }

        .window-title {
            background: #3a3a3a;
            color: #fff;
            padding: 6px 12px;
            font-weight: bold;
            font-size: 14px;
            cursor: default;
            user-select: none;
        }

        .window-content {
            padding: 12px;
            background: #fafafa;
        }

        /* Overlay covers the entire page */
        #overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            /* above everything else */
        }
        .window-content button {
            padding: 6px 12px;
            font-size: 14px;
            border-radius: 4px;
            border: none;
            cursor: pointer;
            background-color: #3a3a3a;
            color: white;
        }

        .window-content button:hover {
            background-color: #555;
        }

        .note-key[data-octave='2'] {
            color: #bbb;
        }
        .note-key[data-octave='4'] {
            color: #bbb;
        }
        label {
            font-size: 12px;
            padding-bottom: 8px;
        }

    </style>
</head>

<body>
    <div id="overlay">
        <div class="window">
            <div class="window-title">Welcome</div>
            <div class="window-content">
                <h1>Under Construction</h1>
                <p>
                    You can create the sound using FM modulation.
                </p>
                <button id="close-btn">I Agree</button>
            </div>
        </div>
    </div>
    <div class="window">
        <div class="window-title">Output</div>
        <div class="window-content">
            <p>
                <canvas id="scope" width="200" height="100"></canvas>
            </p>
        </div>
    </div>

    <div style="display: flex; gap: 8px;">
        <div class="window">
            <div class="window-title">OP0</div>
            <div class="window-content">
                <label>
                    TL
                    <input id="slider-0" type="range" min="0" max="100" value="50">
                </label>
                <fm-envelope id="op0-env"></fm-envelope>
            </div>
        </div>
        <div class="window">
            <div class="window-title">OP1</div>
            <div class="window-content">
                <label>
                    TL
                    <input id="slider-1" type="range" min="0" max="100" value="50">
                </label>
                <fm-envelope id="op1-env"></fm-envelope>
            </div>
        </div>
        <div class="window">
            <div class="window-title">OP2</div>
            <div class="window-content">
                <label>
                    TL
                    <input id="slider-2" type="range" min="0" max="100" value="50">
                </label>
                <fm-envelope id="op2-env"></fm-envelope>
            </div>
        </div>
        <div class="window">
            <div class="window-title">OP3</div>
            <div class="window-content">
                <label>
                    TL
                    <input id="slider-3" type="range" min="0" max="100" value="50">
                </label>
                <fm-envelope id="op3-env"></fm-envelope>
            </div>
        </div>
    </div>

    <div class="window">
        <div class="window-title">Input</div>
        <div class="window-content">
            <button class="note-key" data-note="E" data-octave="2">E2</button>
            <button class="note-key" data-note="F" data-octave="2">F2</button>
            <button class="note-key" data-note="G" data-octave="2">G2</button>
            <button class="note-key" data-note="A" data-octave="2">A2</button>
            <button class="note-key" data-note="B" data-octave="2">B2</button>
            <button class="note-key" data-note="C" data-octave="3">C3</button>
            <button class="note-key" data-note="D" data-octave="3">D3</button>
            <button class="note-key" data-note="E" data-octave="3">E3</button>
            <button class="note-key" data-note="F" data-octave="3">F3</button>
            <button class="note-key" data-note="G" data-octave="3">G3</button>
            <button class="note-key" data-note="A" data-octave="3">A3</button>
            <button class="note-key" data-note="B" data-octave="3">B3</button>
            <button class="note-key" data-note="C" data-octave="4">C4</button>
            <button class="note-key" data-note="D" data-octave="4">D4</button>
            <button class="note-key" data-note="E" data-octave="4">E4</button>
            <button class="note-key" data-note="F" data-octave="4">F4</button>
            <button class="note-key" data-note="G" data-octave="4">G4</button>
        </div>
    </div>
</body>
</body>
<script>
    const overlay = document.getElementById('overlay');
    const welcomeScreenCloser = document.getElementById('close-btn');

    welcomeScreenCloser.addEventListener('click', () => {
        initAudio();
        overlay.style.display = 'none';
    });

    class FMEnvelope extends HTMLElement {
        constructor() {
            super();
            this.attachShadow({ mode: 'open' });

            this.params = {
                AR: 16,
                DR: 16,
                SL: 8,
                SR: 8,
                RR: 8
            };

            this.shadowRoot.innerHTML = `
                    <style>
                        .panel {
                            display: flex;
                            flex-direction: column;
                            gap: 8px;
                            width: 100%;
                        }
                        label {
                            font-size: 12px;
                        }
                        svg {
                            height: 100px;
                            background: #111;
                            border-radius: 6px;
                        }
                        text { fill: #aaa; font-size: 10px; }
                        path { stroke: #4fc3f7; stroke-width: 2; fill: none; }
                    </style>
                    <div class="panel">
                        <svg viewBox="0 0 100 120">
                            <path id="env" />
                        </svg>
                        ${this.slider('AR', 31)}
                        ${this.slider('DR', 31)}
                        ${this.slider('SL', 15)}
                        ${this.slider('SR', 31)}
                        ${this.slider('RR', 31)}
                    </div>
                    `;
        }

        connectedCallback() {
            this.shadowRoot.querySelectorAll('input').forEach(input => {
                input.addEventListener('input', e => {
                    this.params[e.target.name] = Number(e.target.value);
                    this.drawEnvelope();
                });
            });
            this.drawEnvelope();
        }

        slider(name, max) {
            return `<label>
                    ${name}
                    <input type="range" name="${name}" min="0" max="${max}" value="${this.params[name]}" />
                </label>`;
        }

        drawEnvelope() {
            const { AR, DR, SL, SR, RR } = this.params;

            const atk = 20 - AR * 0.5;
            const dec1 = 20 - DR * 0.5;
            const sustainY = 100 - (SL / 15) * 80;
            const dec2 = 20 - SR * 0.5;
            const rel = 20 - RR * 0.5;

            const x0 = 10;
            const y0 = 100;
            const x1 = x0 + atk;
            const y1 = 20;
            const x2 = x1 + dec1;
            const y2 = sustainY;
            const x3 = x2 + dec2;
            const y3 = sustainY;
            const x4 = x3 + rel;
            const y4 = 100;

            const d = `M ${x0} ${y0} L ${x1} ${y1} L ${x2} ${y2} L ${x3} ${y3} L ${x4} ${y4}`;

            this.shadowRoot.getElementById('env').setAttribute('d', d);
        }
    }

    customElements.define('fm-envelope', FMEnvelope);
    const fftSize = 256;
    let ctx;

    const buffer = new Uint8Array(fftSize);
    const scopeCanvas = document.getElementById('scope');
    const gainSliders = [
        document.getElementById('slider-0'),
        document.getElementById('slider-1'),
        document.getElementById('slider-2'),
        document.getElementById('slider-3'),
    ];

    let op3Gain;
    let op4Gain;
    let analyser;
    let ops;
    let opGains;
    const peaks = gainSliders.map(s => s.value);
    let envs = [
        document.querySelector('fm-envelope#op0-env'),
        document.querySelector('fm-envelope#op1-env'),
        document.querySelector('fm-envelope#op2-env'),
        document.querySelector('fm-envelope#op3-env'),
    ];

    const FM_ALGORITHMS = {
        chain: [
            [0, 1],
            [1, 2],
            [2, 3],
            [3, "out"],
        ],

        // example future algorithm
        // two carriers, shared modulator
        parallel: [
            [0, 2],
            [1, 2],
            [2, "out"],
            [3, "out"],
        ],
    };

    function initAudio(algorithmName = "chain") {
        ctx = new AudioContext();

        // Create operators and gains
        ops = Array.from({ length: 4 }, () => ctx.createOscillator());
        opGains = Array.from({ length: 4 }, () => ctx.createGain());

        for (const op of ops) {
            op.type = "sine";
            op.frequency.value = 440;
        }

        analyser = ctx.createAnalyser();
        analyser.fftSize = 256;

        // Build algorithm
        const algorithm = FM_ALGORITHMS[algorithmName];

        for (const [src, dst] of algorithm) {
            if (dst === "out") {
                // Carrier path
                ops[src].connect(opGains[src]);
                opGains[src].connect(analyser);
            } else {
                // FM modulation path
                ops[src].connect(opGains[src]);
                opGains[src].connect(ops[dst].frequency);
            }
        }

        analyser.connect(ctx.destination);

        // Start ops
        const now = ctx.currentTime;
        for (const op of ops) op.start(now);
        for (const g of opGains) g.gain.setValueAtTime(0, now);

        drawScope();
    }

    /* ZONE: Keyboard */ {
        // TODO: these better suit with envelope
        // But I am not too sure if they belong to component,
        // Maybe some separate zone can be introduced for the
        // Envelopes and it could hold the component and
        // those value mappers
        function rateToTime(rate, maxRate, minTime, maxTime, alainfinity) {
            if (rate <= 0) return alainfinity; // special case (SR=0)
            const norm = rate / maxRate;    // 0â€“1
            return maxTime * Math.pow(minTime / maxTime, norm);
        }

        function ARtoTime(AR) {
            return rateToTime(AR, 31, 0.002, 1.0, 1.0); // 2ms .. 1s Inf=1
        }

        function DRtoTime(DR) {
            return rateToTime(DR, 31, 0.01, 2.0, 3.0);  // 10ms .. 2s Inf=1
        }

        function SRtoTime(SR) {
            return rateToTime(SR, 31, 0.5, 30.0, 60.0);  // 0.5s .. 30s
        }

        function RRtoTime(RR) {
            return rateToTime(RR, 31, 0.01, 3.0, 5.0);  // 10ms .. 3s
        }

        function SLtoLevel(SL) {
            return SL / 15;
        }

        function onNotePress(opGain, env, peak = 1.0) {
            const now = ctx.currentTime;

            const atk = ARtoTime(env.AR);
            const dec = DRtoTime(env.DR);
            const susLvl = SLtoLevel(env.SL);
            const susTime = SRtoTime(env.SR);

            const g = opGain.gain;
            g.cancelScheduledValues(now);
            g.setValueAtTime(0, now);

            // Attack
            g.linearRampToValueAtTime(Math.max(0.001, peak), now + atk);

            // Decay to sustain level
            g.linearRampToValueAtTime(
                Math.max(0.001, peak * susLvl),
                now + atk + dec
            );

            // Sustain decay (SR)
            if (env.SR > 0) {
                g.linearRampToValueAtTime(
                    0.001,
                    now + atk + dec + susTime
                );
            }
            // else SR=0 -> hold forever
        }

        function onNoteRelease(opGain, env) {
            const now = ctx.currentTime;
            const relTime = RRtoTime(env.RR);

            const g = opGain.gain;

            // Stop whatever the envelope was doing
            g.cancelScheduledValues(now);

            // Release to silence
            g.linearRampToValueAtTime(0.001, now + relTime);
            setTimeout(() => {
                drawScope(); // One last time when graph is still
            }, relTime * 1_000+ 100);
        }
    }

    function drawScope() {
        requestAnimationFrame(drawScope);

        analyser.getByteTimeDomainData(buffer);

        const ctx = scopeCanvas.getContext('2d');
        const w = scopeCanvas.width;
        const h = scopeCanvas.height;

        ctx.clearRect(0, 0, w, h);
        ctx.beginPath();

        for (let i = 0; i < buffer.length; i++) {
            const x = (i / (buffer.length - 1)) * w;
            const y = (buffer[i] / 255) * h;

            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        }

        ctx.strokeStyle = '#4fc3f7';
        ctx.lineWidth = 3;
        ctx.stroke();
    }

    for (let i = 0; i < 4; i++) {

        const slider = gainSliders[i];
        slider.addEventListener('input', () => {
            peaks[i] = slider.value;
            console.log(`slider[${i}] changed to ${slider.value}`);
        });
    }

    function noteToFrequency(note, octave) {
        // Define the notes and their corresponding semitone offsets from A4
        const notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
        const noteIndex = notes.indexOf(note);

        if (noteIndex === -1) {
            throw new Error("Invalid note name. Use sharps (#) or flats (b), e.g., 'C#' or 'Eb'.");
        }

        // Calculate the semitone difference from A4 (A4 is the 9th note in the list, octave 4)
        const semitoneDiff = noteIndex - 9 + (octave - 4) * 12;

        // Calculate the frequency using the formula: f(n) = 440 * 2^(n/12)
        const frequency = 440 * Math.pow(2, semitoneDiff / 12);
        console.log({note, octave, frequency});

        return frequency;
    }

    document.querySelectorAll('button.note-key').forEach(button => {
        button.addEventListener('mousedown', () => {
            const note = button.dataset.note;
            const octave = button.dataset.octave;
            const frequency = noteToFrequency(note, octave);
            const now = ctx.currentTime;

            ops[3].frequency.setValueAtTime(frequency, now);
            ops[2].frequency.setValueAtTime(frequency * 2, now);
            ops[1].frequency.setValueAtTime(frequency * 0.5, now);
            ops[0].frequency.setValueAtTime(frequency * 8, now);

            for (let i = 0; i < 4; i++) {
                const opGain = opGains[i];
                const env = envs[i];
                const tl = Math.max(0.001, peaks[i] / 100);
                
                if (i === 3) {
                    // Carrier or unused ops: normal amplitude
                    onNotePress(opGain, env.params, tl);
                } else {
                    const fmDepth = tl * tl * 1200;
                    onNotePress(opGain, env.params, fmDepth);
                }
           }
        });

        button.addEventListener('mouseup', () => {
            for (let i = 0; i < 4; i++) {
                onNoteRelease(opGains[i], envs[i].params);
            }
        }); 
    })
</script>

</html>